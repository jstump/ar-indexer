module ARIndexer

	# Simple class for searching the index generated by adding has_reverse_index to ActiveRecord models
	# 
	# === Initialization
	# 
	#   foo = IndexSearch.new(Article, {:no_results_message => "We're sorry, but no results were found"})
	# 
	# === Parameters
	# 
	# * model_name: constant denoting the ActiveRecord model to search
	# * opts: optional hash of configuration options
	# 
	# === Options
	# 
	# :no_results_message => string which can be requested and displayed if no results are found

	class IndexSearch

		def initialize(model_name, opts = {})
			@model_name = model_name.to_s.split('::').last
			@model_class = @model_name.constantize

			@options = {
				:no_results_message => "Your #{@model_name} search returned no results."
			}

			@options.merge!(opts)
		end

		# Returns either the default :no_results_message, or the one specified on initialization

		def no_results_message
			return @options[:no_results_message]
		end

		# Runs a text search against the ReverseIndex model for a given ActiveRecord model and search string.
		# Returns 
		# 
		# ==== Parameters
		# 
		# * search_string: string on which to search for indexed objects
		# 
		# ==== Examples
		# 
		#   foo = IndexSearch.new(Article)
		#   foo.run_search("test string")
		#   #=> [<#Article>, <#Article>, ...]

		def run_search(search_string)
			search_terms = Indexer.text_to_lexicon(search_string)
			match_counts = {}
			search_terms.each do |st|
				if reverse_index_record = ReverseIndex.where(:model_name => @model_name, :word => st).first
					reverse_index_record.retrieve_id_array.each do |id|
						if match_counts.has_key?(id)
							match_counts[id] = match_counts[id] + 1
						else
							match_counts[id] = 1
						end
					end
				end
			end
			unless match_counts.empty?
				objects_to_return = []
				match_counts.to_a.sort{|x,y| x[1] <=> y[1]}.collect{|x| x[0]}.reverse.each do |id|
					objects_to_return << @model_class.find(id)
				end
				return objects_to_return
			else
				return []
			end
		end

	end

end
